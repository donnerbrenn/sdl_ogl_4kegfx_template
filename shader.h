/* File generated with Shader Minifier 1.1.5
 * http://www.ctrl-alt-test.fr
 */
#ifndef SHADER_H_
# define SHADER_H_
# define VAR_RUNTIME "v"

const char *shader_frag =
 "uniform float v[3];"
 "float f=v[0],m=v[2]/v[1];"
 "mat3 n(vec3 v)"
 "{"
   "float f=cos(v.x),y=sin(v.x),m=cos(v.y),x=sin(v.y),n=cos(v.z),l=sin(v.z);"
   "mat3 r=mat3(vec3(1,0,0),vec3(0,f,-y),vec3(0,y,f));"
   "r*=mat3(vec3(m,0,x),vec3(0,1,0),vec3(-x,0,m));"
   "return r*mat3(vec3(n,-l,0),vec3(l,n,0),vec3(0,0,1));"
 "}"
 "float n(vec3 v,vec3 l,float y)"
 "{"
   "vec3 f=abs(v)-l;"
   "return length(max(f,0.))+min(max(f.x,max(f.y,f.z)),0.)-y;"
 "}"
 "float n(vec3 v,float y)"
 "{"
   "return length(v)-y;"
 "}"
 "float s(vec3 v,vec2 y)"
 "{"
   "vec2 f=vec2(length(v.xz)-y.x,v.y);"
   "return length(f)-y.y;"
 "}"
 "float n(vec3 v,float f,float y,float l)"
 "{"
   "vec2 m=vec2(length(v.xz)-2.*f+y,abs(v.y)-l);"
   "return min(max(m.x,m.y),0.)+length(max(m,0.))-y;"
 "}"
 "float h(vec3 v,float y)"
 "{"
   "v=abs(v);"
   "float f=v.x+v.y+v.z-y;"
   "vec3 m;"
   "if(3.*v.x<f)"
     "m=v.xyz;"
   "else"
     " if(3.*v.y<f)"
       "m=v.yzx;"
     "else"
       " if(3.*v.z<f)"
         "m=v.zxy;"
       "else"
         " return f*.57735;"
   "float l=clamp(.5*(m.z-m.y+y),0.,y);"
   "return length(vec3(m.x,m.y-y+l,m.z-l));"
 "}"
 "float h(vec3 v)"
 "{"
   "vec3 m=v;"
   "v=n(vec3(1,0,0))*v;"
   "v.z-=1.5;"
   "float y=n(v,vec3(4,4,.01),.1);"
   "v=n(vec3(1,f,sin(f*.5)*.5))*m;"
   "float l=s(v,vec2(.7,.25)),x=n(mod(v,.5)-.25,vec3(.5),.05),a=n(v,.5),r=n(v,.5,.5,.01),i=h(v,1.),d=mix(a,x,abs(sin(f*.5))*.5);"
   "return min(d,y);"
 "}"
 "vec3 s(vec3 v)"
 "{"
   "vec2 m=vec2(.005,0);"
   "return normalize(vec3(h(v+m.xyy)-h(v-m.xyy),h(v+m.yxy)-h(v-m.yxy),h(v+m.yyx)-h(v-m.yyx)));"
 "}"
 "float h(vec3 v,vec3 y,float f)"
 "{"
   "return(dot(v,normalize(y))*.5+.5)*f;"
 "}"
 "float h(vec3 v,vec3 y,vec3 m,float f)"
 "{"
   "vec3 l=reflect(normalize(y),v);"
   "return pow(max(dot(m,l),0),32)*f;"
 "}"
 "float h(in vec3 v,in vec3 f,float m,float y,float l)"
 "{"
   "float x=1.,r=1e+20;"
   "for(float z=m;z<y;)"
     "{"
       "float n=h(v+f*z);"
       "if(n<.001)"
         "return 0.;"
       "float i=n*n/(2.*r),a=sqrt(n*n-i*i);"
       "x=min(x,l*a/max(0.,z-i));"
       "r=n;"
       "z+=n;"
     "}"
   "return smoothstep(0.,.2,x);"
 "}"
 "void main()"
 "{"
   "vec2 f=(gl_FragCoord.xy/vec2(v[1],v[2])-.5)/vec2(m,1);"
   "vec3 y=vec3(0.,0.,-3.),l=y,x=normalize(vec3(f,1.));"
   "float r=0.;"
   "vec3 n;"
   "for(float i=0;i<400.;i++)"
     "{"
       "float a=h(l);"
       "if(a<.001)"
         "{"
           "r=l/.1;"
           "vec3 d=s(l),z=vec3(1,.5,-.5),e=vec3(-.5,.4,.1),t=vec3(-.5,1.8,-.1);"
           "float g=h(d,z,.125)+h(d,z,x,.9),c=h(d,e,.035)+h(d,e,x,.4),o=h(d,t,.0125)+h(d,t,x,.14);"
           "n=vec3(g+c+o)+vec3(.8,0,0);"
           "float p=length(y-l);"
           "vec3 u=y+p*x;"
           "n*=h(u,normalize(z),.1,10.,length(z-u)*2)*.5+.5;"
           "break;"
         "}"
       "l+=a*x;"
     "}"
   "float i=length(y-l);"
   "n*=mix(n,vec3(1.,1.,1.),1-exp(-.1*i*i));"
   "gl_FragColor=vec4(n,1);"
 "}";

#endif // SHADER_H_
